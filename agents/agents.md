# AIQueue Agents – Master Overview (agents.md)

**Date:** 2025-08-08\
**Owner:** AIQueue Orchestrator (MasterAgent)

---

## Purpose

Single source of truth for agents, capabilities, and the 3-track task system. Includes **surgical edit instructions** to wire this doc generation into `aiq_master_agent.py`.

---

## 0) Three Task Tracks (operational contract)

- **OnTarget** — ready now; deps satisfied; executed by agents.
- **DelegationStation** — needs a different agent or human nudge.
- **BackBurner** — ideas, blocked, or awaiting resources.

---

## 1) Current Agents (implemented)

- **ResearchAgent** — `metadata.type == "research"` → produces background briefs.
- **ContentAgent** — `metadata.type == "content"` → drafts/edits content assets.

---

## 2) Planned Agents (next up)

> Below are **drop-in specs** you can implement as classes under the *AGENT INTERFACES* section and register in the **AgentFactory registry**.

### 2.1 VideoEditAgent (HIGH PRIORITY)

- **Capability key:** `"video_edit"`
- **can\_handle:** `task.metadata.type == "video_edit"`
- **handle:** simulate trim/overlay → set `task.metadata["video_cut_url"]`.
- **Track usage:** OnTarget for small edits; Delegation if external tool needed.

### 2.2 BrandVoiceAgent

- **Capability key:** `"brand_voice"`
- **Role:** rewrite text to AIQ tone (electric/bold/clean).
- **Inputs:** `task.metadata.text`; **Output:** `task.metadata.text_polished`.

### 2.3 PromptOptimizerAgent

- **Capability key:** `"prompt_opt"`
- **Role:** refine prompts for target LLM/tool; stash at `task.metadata.optimized_prompt`.

### 2.4 WorkflowManagerAgent (lightweight)

- **Capability key:** `"workflow"`
- **Role:** expand multi-step goals into atomic tasks (helper to BackwardPlanner).

### 2.5 SocialPosterAgent

- **Capability key:** `"social_post"`
- **Role:** simulate posting; set `task.metadata.post_id`.

### 2.6 AnalyticsAgent

- **Capability key:** `"analytics"`
- **Role:** read metrics, write `task.metadata.insights` and suggested next actions.

---

## 3) Registry & Resolution Map (authoritative)

Add to **AgentFactory.\_registry** (between markers):

```python
# === BEGIN EDIT BLOCK: AGENT REGISTRY
_registry = {
    "research": lambda n: ResearchAgent(n),
    "content":  lambda n: ContentAgent(n),
    "video_edit": lambda n: VideoEditAgent(n),
    "brand_voice": lambda n: BrandVoiceAgent(n),
    "prompt_opt": lambda n: PromptOptimizerAgent(n),
    "workflow": lambda n: WorkflowManagerAgent(n),
    "social_post": lambda n: SocialPosterAgent(n),
    "analytics": lambda n: AnalyticsAgent(n),
}
# === END EDIT BLOCK: AGENT REGISTRY
```

Update **MasterAgent.resolve\_capability** (between markers):

```python
# === BEGIN EDIT BLOCK: CAPABILITY RESOLUTION
return task.metadata.get("type")  # expects one of the keys above
# === END EDIT BLOCK: CAPABILITY RESOLUTION
```

---

## 4) Backward Planning: default milestones (editable)

Backward → forward chain:

1. **Publish asset** → tasks: write title/desc (OnTarget, content), schedule (Delegation, social\_post).
2. **Produce final asset** → tasks: finalize edit (OnTarget, content|video\_edit).
3. **Research & outline** → tasks: background brief (OnTarget, research), outline (Delegation, content).

> You can swap/extend milestones per goal in `BackwardPlanner`.

---

## 5) CODE PATCH: make MasterAgent write this agents.md automatically

**Where:** `aiq_master_agent.py`\
**Insert after** the `MasterAgent.summary()` method **and before** `# === END: MASTER ORCHESTRATOR (AIQ)`.

```python
# === BEGIN ADD BLOCK: DOC EMITTER ===================================
    def write_agents_md(self, path: str = "agents.md") -> None:
        """Emit a fresh agents.md with current registry + counts."""
        lines = []
        lines.append("# AIQueue Agents – Master Overview (generated)\n")
        lines.append("Generated by MasterAgent\n\n")
        lines.append("## Task Summary\n")
        s = self.summary()
        lines.append(f"- OnTarget: {s['on_target']}  ")
        lines.append(f"- Delegation: {s['delegation']}  ")
        lines.append(f"- BackBurner: {s['back_burner']}  \n\n")
        # Agent registry snapshot
        lines.append("## Agent Registry\n")
        try:
            keys = sorted(AgentFactory._registry.keys())
            for k in keys:
                lines.append(f"- {k}\n")
        except Exception as e:
            lines.append(f"(error reading registry: {e})\n")
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))
        log(f"Wrote {path}")
# === END ADD BLOCK: DOC EMITTER =====================================
```

**Main demo update:** in the `__main__` block, **append after** the loop and **before** printing the summary:

```python
# === BEGIN ADD BLOCK: GENERATE agents.md ============================
    master.write_agents_md("agents.md")
# === END ADD BLOCK: GENERATE agents.md ==============================
```

---

## 6) Known Issues / Fix First Tomorrow

1. **Syntax bug in AgentFactory**: stray line outside dict → delete the dangling line `"video_edit": lambda n: VideoEditAgent(n),` that sits **after** `_registry = {...}`. Keep everything **inside** the dict.
2. **Missing classes**: implement stubs for the planned agents **before** referencing them in registry.
3. **Capability hygiene**: ensure every emitted task sets `metadata.type` to a valid key.
4. **Human-in-the-loop**: wire a notifier (stdout ok) for DelegationStation items.

---

## 7) Minimal Stubs (copy-paste under AGENT INTERFACES)

```python
class VideoEditAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "video_edit"
    def handle(self, task: Task) -> TaskStatus:
        log(f"{self.name} editing video: {task.title}")
        time.sleep(0.05)
        task.metadata["video_cut_url"] = "s3://bucket/clip.mp4"
        return TaskStatus.DONE

class BrandVoiceAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "brand_voice"
    def handle(self, task: Task) -> TaskStatus:
        txt = task.metadata.get("text", "")
        task.metadata["text_polished"] = f"[AIQ tone] {txt}"
        return TaskStatus.DONE

class PromptOptimizerAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "prompt_opt"
    def handle(self, task: Task) -> TaskStatus:
        raw = task.metadata.get("prompt", "")
        task.metadata["optimized_prompt"] = raw.strip() + "\n# tuned"
        return TaskStatus.DONE

class WorkflowManagerAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "workflow"
    def handle(self, task: Task) -> TaskStatus:
        # Could emit sub-tasks via BackwardPlanner in future
        task.metadata["expanded"] = True
        return TaskStatus.DONE

class SocialPosterAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "social_post"
    def handle(self, task: Task) -> TaskStatus:
        task.metadata["post_id"] = f"POST-{uuid.uuid4().hex[:8]}"
        return TaskStatus.DONE

class AnalyticsAgent(BaseAgent):
    def can_handle(self, task: Task) -> bool:
        return task.metadata.get("type") == "analytics"
    def handle(self, task: Task) -> TaskStatus:
        task.metadata["insights"] = {"next": "Try brighter hook, add CTA"}
        return TaskStatus.DONE
```

---

## 8) Optional: emit tasks for new agents (quick drop-ins)

- In `expand_milestone("Produce final asset")`, **append** a `VideoEditAgent` task:\
  `Task(..., metadata={"type": "video_edit"})`
- In `expand_milestone("Publish asset")`, set the scheduler task to `metadata.type = "social_post"`.
- Add a polishing pass anywhere with `metadata.type = "brand_voice"`.

---

## 9) Done-Definition (DOD) for this sprint

- Build stubs above
- Fix registry bug
- Call `write_agents_md()` from `__main__`
- After run: `agents.md` exists and lists registry + track counts

---

*End of file.*

